define endian    = little;
define alignment = 2;

define space ram      type=ram_space      size=4 default;
define space register type=register_space size=4;

#############################################################################
#
# General purpose registers
#
define register offset=0x0 size=4
	[ r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 ];

# Paired registers
define register offset=0x0 size=8
	[ r0_r1 r2_r3 r4_r5 r6_r7 r8_r9 r10_r11 r12_r13 r14_r15 ];

#
# Special function registers
#
define register offset=0x100 size=4
	[ reti rete retx rets sr4 psr cnum sr7
	  sr8  sr9  sr10 icfg usp ssp sp   pc ];

#############################################################################
#
# Instruction tokens
#

# Base word
define token instr(16)
	group = (13,15)

	#
	# instruction type fields
	#
	ins0012 = (0,12)
	ins0312 = (3,12)
	ins0412 = (4,12)
	ins0612 = (6,12)
	ins0712 = (7,12)
	ins0812 = (8,12)
	ins0912 = (9,12)

	ins0307 = (3,7)
	ins0407 = (4,7)
	ins0607 = (6,7)
	ins0707 = (7,7)

	ins0004 = (0,4)
	ins0304 = (3,4)

	ins0003 = (0,3)
	ins0203 = (2,3)
	ins0303 = (3,3)

	#
	# immediate fields
	#
	imm0001s = (0,1) signed

	imm0002 = (0,2)

	imm0005s = (0,5) signed
	imm0305  = (3,5)
	imm0305s = (3,5) signed

	imm0506  = (5,6)
	imm0406s = (4,6) signed

	imm0407  = (4,7)
	imm0507s = (5,7) signed

	imm0812  = (8,12)
	imm0812s = (8,12) signed

	#
	# register fields
	#
	regA = (0,3)
	regB = (4,7)

	regAl = (0,2)
	regAh = (0,2)
	regBl = (4,6)

	regCxle = (7,8)
	regCxlo = (7,8)
	regCxs  = (3,3)

	dregA = (1,3)
	dregB = (5,7)

	sregA = (0,3)
;

# Used by the group=7 instructions
define token instr2(16)
	imm1631 = (0,15)
;

# Even more bits for some group=7 instructions
define token instr3(16)
	imm3247 = (0,15)
;

#############################################################################
#
# Variables
#

attach variables [ regAl regBl ]
	[ r0 r1 r2 r3 r4 r5 r6 r7 ];

attach variables [ regAh ]
	[ r8 r9 r10 r11 r12 r13 r14 r15 ];

attach variables [ regA regB ]
	[ r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 ];

attach variables [ sregA ]
	[ reti rete retx rets sr4 psr cnum sr7
	  sr8  sr9  sr10 icfg usp ssp sp   pc ];

attach variables [ dregA dregB ]
	[ r0_r1 r2_r3 r4_r5 r6_r7 r8_r9 r10_r11 r12_r13 r14_r15 ];

attach variables [ regCxle ]
	[ r0 r2 r4 r6 ];

attach variables [ regCxlo ]
	[ r1 r3 r5 r7 ];

# PSR bits
@define V	"psr[0,1]"	# overflow
@define C	"psr[1,1]"	# carry
@define Z	"psr[2,1]"	# zero
@define N	"psr[3,1]"	# negative

#############################################################################
#
# Macros
#

macro push(reg)
{
	sp = sp - 4;
	*:4 sp = reg;
}

macro pop(reg)
{
	reg = *:4 sp;
	sp = sp + 4;
}

#############################################################################
#
# Stuff
#

# weird register split addressing..
regCxl: regCxle is regCxs=0 & regCxle { export regCxle; }
regCxl: regCxlo is regCxs=1 & regCxlo { export regCxlo; }

#
# 9-bit jump immediate (pc-relative)
#
jaddr9: res is imm0812 & imm0406s
	[ res = ((imm0406s << 6) | (imm0812 << 1)) + inst_next; ]
	{ export *:4 res; }

#
# 12-bit jump immediate (pc-relative)
#
jaddr12: res is imm0812 & imm0407 & imm0001s
	[ res = ((imm0001s << 10) | (imm0407 << 6) | (imm0812 << 1)) + inst_next; ]
	{ export *:4 res; }

#
# 23-bit jump immediate (pc-relative)
#
jaddr23: res is imm0005s ; imm1631
	[ res = ((imm0005s << 17) | (imm1631 << 1)) + inst_next; ]
	{ export *:4 res; }

#############################################################################
#
# Instructions
#

define pcodeop nop;
define pcodeop Idle;
define pcodeop Breakpoint;
define pcodeop HBreakpoint;
define pcodeop ContextSync;
define pcodeop SystemCall;
define pcodeop SSync;
define pcodeop BTBClear;
define pcodeop ClearLock;
define pcodeop SetLock;
define pcodeop DisableInterrupts;
define pcodeop EnableInterrupts;
define pcodeop SoftwareInterrupt;
define pcodeop CachePrefetch;
define pcodeop ICacheFlush;
define pcodeop CacheFlush;
define pcodeop CacheFlushInvalidate;

define pcodeop TODO;

############################################################################################
# Group 0 #
###########

#
# nop
#
:nop is group=0 & ins0012=0x0000
{
	nop();
}

#
# idle
#
:idle is group=0 & ins0012=0x0001
{
	Idle();
}

#
# bkpt
#
:bkpt is group=0 & ins0012=0x0002
{
	Breakpoint();
}

#
# hbkpt
#
:hbkpt is group=0 & ins0012=0x0003
{
	HBreakpoint();
}

#
# csync
#
:csync is group=0 & ins0012=0x0020
{
	ContextSync();
}

#
# syscall
#
:syscall is group=0 & ins0012=0x0021
{
	SystemCall();
}

#
# ssync
#
:ssync is group=0 & ins0012=0x0022
{
	SSync();
}

#
# btbclr
#
:btbclr is group=0 & ins0012=0x0023
{
	BTBClear();
}

#
# lockclr
#
:lockclr is group=0 & ins0012=0x0040
{
	ClearLock();
}

#
# lockset
#
:lockset is group=0 & ins0012=0x0041
{
	SetLock();
}

#
# cli
#
:cli is group=0 & ins0012=0x0060
{
	DisableInterrupts();
}

#
# sti
#
:sti is group=0 & ins0012=0x0061
{
	EnableInterrupts();
}

#
# rts
#
:rts is group=0 & ins0012=0x0080
{
	return [rets];
}

#
# rti
#
:rti is group=0 & ins0012=0x0081
{
	ssp = sp;
	sp = usp;
	return [reti];
}

#
# rtx
#
:rtx is group=0 & ins0012=0x0082
{
	# probably swaps the stack pointers too..
	return [retx];
}

#
# rte
#
:rte is group=0 & ins0012=0x0083
{
	# probably swaps the stack pointers too..
	return [rete];
}

#
# swi imm3
#
:swi imm0002 is group=0 & ins0412=0x00A & imm0002
{
	SoftwareInterrupt(imm0002:1);
}

#
# testset b[rA]
#
:testset "b"[regA] is group=0 & ins0412=0x00B & regA
{
	TODO(regA:4);
}

#
# call rA
#
:call regA is group=0 & ins0412=0x00C & regA
{
	call regA;
}

#
# goto rA
#
:goto regA is group=0 & ins0412=0x00D & regA
{
	goto regA;
}

#
# cli rA
#
:cli regA is group=0 & ins0412=0x00E & regA
{
	DisableInterrupts(regA:4);
}

#
# sti rA
#
:sti regA is group=0 & ins0412=0x00F & regA
{
	EnableInterrupts(regA:4);
}

#
# tbb rA
#
:tbb regA is group=0 & ins0412=0x010 & regA
{
	TODO(regA:4);
}

#
# tbh rA
#
:tbh regA is group=0 & ins0412=0x011 & regA
{
	TODO(regA:4);
}

#
# pfetch [rA]
#
:pfetch [regA] is group=0 & ins0412=0x020 & regA
{
	CachePrefetch(regA:4);
}

#
# iflush [rA]
#
:iflush [regA] is group=0 & ins0412=0x021 & regA
{
	ICacheFlush(regA:4);
}

#
# flush [rA]
#
:flush [regA] is group=0 & ins0412=0x022 & regA
{
	CacheFlush(regA:4);
}

#
# flushinv [rA]
#
:flushinv [regA] is group=0 & ins0412=0x023 & regA
{
	CacheFlushInvalidate(regA:4);
}

#
# rep nwords, rA { <nwords> instruction words }
#
###:rep xxx, regA is group=0 & ins0812=0x03 & regA & xxx
### TODO

#
# pc = [sp++]
# <G> pop pc
#
:pop pc is group=0 & ins0012=0x0400 & pc
{
	pop(pc);
}

#
# [--sp] = rets
# <G> push rets
#
:push rets is group=0 & ins0012=0x0410 & rets
{
	push(rets);
}

### .... ###

#
# cc = 0
# <G> clc
#
:clc is group=0 & ins0012=0x1400
{
	$(C) = 0;
}

#
# cc = 1
# <G> stc
#
:stc is group=0 & ins0012=0x1401
{
	$(C) = 1;
}

#
# sp = usp
# <G> mov sp, usp
#
:mov sp, usp is group=0 & ins0012=0x1440 & sp & usp
{
	sp = usp;
}

#
# sp = ssp
# <G> mov sp, ssp
#
:mov sp, ssp is group=0 & ins0012=0x1441 & sp & ssp
{
	sp = ssp;
}

#
# usp = sp
# <G> mov usp, sp
#
:mov usp, sp is group=0 & ins0012=0x1442 & sp & usp
{
	usp = sp;
}

#
# ssp = sp
# <G> mov ssp, sp
#
:mov ssp, sp is group=0 & ins0012=0x1443 & sp & ssp
{
	ssp = sp;
}

#
# rA_rA = 0
# <G> clr rA_rA
#
:clr dregA is group=0 & ins0412=0x148 & dregA
{
	dregA = 0;
}

#
# rA<8-15> = 0
# <G> clr rA<8-15>
#
:clr regAh is group=0 & ins0312=0x298 & regAh
{
	regAh = 0;
}

#
# rA_rA = rB_rB
# <G> mov rA_rA, rB_rB
#
:mov dregA, dregB is group=0 & ins0812=0x15 & dregA & dregB
{
	dregA = dregB;
}

#
# rA = rB
# <G> mov rA, rB
#
:mov regA, regB is group=0 & ins0812=0x16 & regA & regB
{
	regA = regB;
}

#
# rA = rB.b0 (u)
# <G> uxtb rA, rB
#
:uxtb regAl, regBl is group=0 & ins0712=0x2E & ins0303=0 & regAl & regBl
{
	regAl = zext(regBl:1);
}

#
# rA = rB.b0 (s)
# <G> sxtb rA, rB
#
:sxtb regAl, regBl is group=0 & ins0712=0x2E & ins0303=1 & regAl & regBl
{
	regAl = sext(regBl:1);
}

#
# rA = rB.l (u)
# <G> uxth rA, rB
#
:uxth regAl, regBl is group=0 & ins0712=0x2F & ins0303=0 & regAl & regBl
{
	regAl = zext(regBl:2);
}

#
# rA = rB.l (s)
# <G> sxth rA, rB
#
:sxth regAl, regBl is group=0 & ins0712=0x2F & ins0303=1 & regAl & regBl
{
	regAl = sext(regBl:2);
}

#
# rA += rB
# <G> add rA, rB
#
:add regA, regB is group=0 & ins0812=0x18 & regA & regB
{
	regA = regA + regB;
}

#
# rA |= rB
# <G> or rA, rB
#
:or regAl, regBl is group=0 & ins0712=0x32 & ins0303=0 & regAl & regBl
{
	regAl = regAl | regBl;
}

#
# rA ^= rB
# <G> xor rA, rB
#
:xor regAl, regBl is group=0 & ins0712=0x32 & ins0303=1 & regAl & regBl
{
	regAl = regAl ^ regBl;
}

#
# rA = ~rB
# <G> not rA, rB
#
:not regAl, regBl is group=0 & ins0712=0x33 & ins0303=0 & regAl & regBl
{
	regAl = ~regBl;
}

#
# rA &= rB
# <G> and rA, rB
#
:and regAl, regBl is group=0 & ins0712=0x33 & ins0303=1 & regAl & regBl
{
	regAl = regAl & regBl;
}

#
# rA <<= rB
# <G> lsl rA, rB
#
:lsl regAl, regBl is group=0 & ins0712=0x34 & ins0303=0 & regAl & regBl
{
	regAl = regAl << regBl;
}

#
# rA <<<= rB
# <G> qasl rA, rB
#
:qasl regAl, regBl is group=0 & ins0712=0x34 & ins0303=1 & regAl & regBl
{
	# TODO... duplicate the LSB (i guess)
	regAl = regAl << regBl;
}

#
# rA >>= rB
# <G> lsr rA, rB
#
:lsr regAl, regBl is group=0 & ins0712=0x35 & ins0303=0 & regAl & regBl
{
	regAl = regAl >> regBl;
}

#
# rA >>>= rB
# <G> qasr rA, rB
#
:qasr regAl, regBl is group=0 & ins0712=0x35 & ins0303=1 & regAl & regBl
{
	regAl = regAl s>> regBl;
}

#
# rA *= rB
# <G> mul rA, rB
#
:mul regA, regB is group=0 & ins0812=0x1B & regA & regB
{
	regA = regA * regB;
}

#
# rA = rB + rC
# <G> add rA, rB, rC
#
:add regAl, regBl, regCxl is group=0 & ins0912=0xE & regAl & regBl & regCxl
{
	regAl = regBl + regCxl;
}

#
# rA = rB - rC
# <G> sub rA, rB, rC
#
:sub regAl, regBl, regCxl is group=0 & ins0912=0xF & regAl & regBl & regCxl
{
	regAl = regBl - regCxl;
}

############################################################################################
# Group 1 #
###########


#
# rA |= (1<<shamt)
# <G> bitset rA, shamt
#
:bitset regAl, imm0812 is group=1 & ins0307=0x06 & regAl & imm0812
{
	regAl = regAl | (1 << imm0812);
}

#
# rA ^= (1<<shamt)
# <G> bittgl rA, shamt
#
:bittgl regAl, imm0812 is group=1 & ins0307=0x07 & regAl & imm0812
{
	regAl = regAl ^ (1 << imm0812);
}


#
# rA = imm8
# <G> mov rA, imm8
#
:mov regAl, imm8 is group=1 & ins0607=1 & regAl & imm0812 & imm0305
[ imm8 = (imm0305 << 5) | imm0812; ]
{
	regAl = imm8;
}


#
# rA &= ~(1<<shamt)
# <G> bitclr rA, shamt
#
:bitclr regAl, imm0812 is group=1 & ins0307=0x17 & regAl & imm0812
{
	regAl = regAl & ~(1 << imm0812);
}

#
# rA += imm8
# <G> add rA, imm8
#
:add regAl, imm8 is group=1 & ins0607=3 & regAl & imm0305s & imm0812
[ imm8 = (imm0305s << 5) | imm0812; ]
{
	regAl = regAl + imm8;
}

############################################################################################
# Group 2 #
###########

#
# if (rA == 0) goto reladdr9
# <G> jz rA, reladdr9
#
:jz regAl, jaddr9 is group=2 & ins0707=0 & ins0303=0 & regAl & jaddr9
{
	if (regAl == 0)
		goto jaddr9;
}

#
# if (rA != 0) goto reladdr9
# <G> jnz rA, reladdr9
#
:jz regAl, jaddr9 is group=2 & ins0707=1 & ins0303=0 & regAl & jaddr9
{
	if (regAl == 0)
		goto jaddr9;
}

#
# rA = b[rB+reladdr5] (u)
# <G> lbz rA, rB, reladdr5
#
:lbz regAl, regBl, imm0812s is group=2 & ins0707=0 & ins0303=1 & regAl & regBl & imm0812s
{
	local addr:4 = regBl + imm0812s;
	regAl = zext(*:1 addr);
}

#
# b[rB+reladdr5] = rA
# <G> sb rA, rB, reladdr5
#
:sb regAl, regBl, imm0812s is group=2 & ins0707=1 & ins0303=1 & regAl & regBl & imm0812s
{
	local addr:4 = regBl + imm0812s;
	*:1 addr = regAl;
}

############################################################################################
# Group 3 #
###########

#
# rA = [rB+reladdr7]
# <G> lw rA, reladdr7
#
:lw regAl, regBl, rel7 is group=3 & ins0707=0 & ins0303=0 & regAl & regBl & imm0812s
[ rel7 = (imm0812s << 2); ]
{
	local addr:4 = regBl + rel7;
	regAl = *:4 addr;
}

#
# [rB+reladdr7] = rA
# <G> sw rA, reladdr7
#
:sw regAl, regBl, rel7 is group=3 & ins0707=1 & ins0303=0 & regAl & regBl & imm0812s
[ rel7 = (imm0812s << 2); ]
{
	local addr:4 = regBl + rel7;
	*:4 addr = regAl;
}

#
# rA = h[rB+reladdr6] (u)
# <G> lhz rA, reladdr6
#
:lhz regAl, regBl, rel6 is group=3 & ins0707=0 & ins0303=1 & regAl & regBl & imm0812s
[ rel6 = (imm0812s << 1); ]
{
	local addr:4 = regBl + rel6;
	regAl = zext(*:2 addr);
}

#
# h[rB+reladdr7] = rA
# <G> sh rA, reladdr7
#
:sh regAl, regBl, rel6 is group=3 & ins0707=1 & ins0303=1 & regAl & regBl & imm0812s
[ rel6 = (imm0812s << 1); ]
{
	local addr:4 = regBl + rel6;
	*:2 addr = regAl;
}

############################################################################################
# Group 4 #
###########

#
# call reladdr9
#
:call jaddr9 is group=4 & ins0707=0 & ins0003=0x1 & jaddr9
{
	call jaddr9;
}

#
# sp += imm10
# <G> add sp, imm10
#
:add sp, imm10 is group=4 & ins0004=0x02 & imm0812 & imm0507s & sp
[ imm10 = (imm0507s << 7) | (imm0812 << 2); ]
{
	sp = sp + imm10;
}

#
# goto reladdr12
#
:goto jaddr12 is group=4 & ins0203=1 & jaddr12
{
	goto jaddr12;
}

#
# rA = rB + imm5
# <G> add rA, rB, imm5
#
:add regAl, regBl, imm0812 is group=4 & ins0707=0 & ins0303=1 & regAl & regBl & imm0812
{
	regAl = regBl + imm0812;
}

#
# rA = sp + imm7
# <G> add rA, sp, imm7
#
:add regAl, sp, imm7 is group=4 & ins0707=1 & ins0304=1 & regAl & sp & imm0812 & imm0506
[ imm7 = (imm0506 << 5) | imm0812; ]
{
	regAl = sp + imm7;
}

############################################################################################
# Group 5 #
###########

## ! TODO, 0 means 32 ! ##

#
# rA = rB << shamt
# <G> lsl rA, rB, shamt
#
:lsl regAl, regBl, imm0812 is group=5 & ins0707=0 & ins0303=0 & regAl & regBl & imm0812
{
	regAl = regBl << imm0812;
}

#
# rA = rB <<< shamt
# <G> qasl rA, rB, shamt
#
:qasl regAl, regBl, imm0812 is group=5 & ins0707=0 & ins0303=1 & regAl & regBl & imm0812
{
	# TODO extend the LSB
	regAl = regBl << imm0812;
}

#
# rA = rB >> shamt
# <G> lsr rA, rB, shamt
#
:lsr regAl, regBl, imm0812 is group=5 & ins0707=1 & ins0303=0 & regAl & regBl & imm0812
{
	regAl = regBl >> imm0812;
}

#
# rA = rB >>> shamt
# <G> qasr rA, rB, shamt
#
:qasr regAl, regBl, imm0812 is group=5 & ins0707=1 & ins0303=1 & regAl & regBl & imm0812
{
	regAl = regBl s>> imm0812;
}

############################################################################################
# Group 6 #
###########

############################################################################################
# Group 7 #
###########



#
# call reladdr22
#
:call jaddr23 is (group=7 & ins0612=0x2A) ... & jaddr23
{
	call jaddr23;
}

#
# goto reladdr22
#
:goto jaddr23 is (group=7 & ins0612=0x2B) ... & jaddr23
{
	goto jaddr23;
}




#
# rA = imm32
# <G> mov rA, imm32
#
:mov regA, imm32 is group=7 & ins0412=0x1FC & regA ; imm1631 ; imm3247
[ imm32 = imm1631 | (imm3247 << 16); ]
{
	regA = imm32;
}

#
# srA = imm32
# <G> mov srA, imm32
#
:mov sregA, imm32 is group=7 & ins0412=0x1FE & sregA ; imm1631 ; imm3247
[ imm32 = imm1631 | (imm3247 << 16); ]
{
	sregA = imm32;
}
