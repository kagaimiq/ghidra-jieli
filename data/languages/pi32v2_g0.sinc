############################################################################################
# Group 0 #
###########

#
# nop
#
:nop is group=0 & ins0012=0x0000
{
	nop();
}

#
# idle
#
:idle is group=0 & ins0012=0x0001
{
	Idle();
}

#
# bkpt
#
:bkpt is group=0 & ins0012=0x0002
{
	Breakpoint();
}

#
# hbkpt
#
:hbkpt is group=0 & ins0012=0x0003
{
	HBreakpoint();
}

#
# csync
#
:csync is group=0 & ins0012=0x0020
{
	CoreSynchronize();
}

#
# syscall
#
:syscall is group=0 & ins0012=0x0021
{
	SystemCall();
}

#
# ssync
#
:ssync is group=0 & ins0012=0x0022
{
	SystemSynchronize();
}

#
# btbclr
#
:btbclr is group=0 & ins0012=0x0023
{
	BTBClear();
}

#
# lockclr
#
:lockclr is group=0 & ins0012=0x0040
{
	ClearLock();
}

#
# lockset
#
:lockset is group=0 & ins0012=0x0041
{
	SetLock();
}

#
# cli
#
:cli is group=0 & ins0012=0x0060
{
	DisableInterrupts();
}

#
# sti
#
:sti is group=0 & ins0012=0x0061
{
	EnableInterrupts();
}

#
# swi imm3
#
:swi imm0002 is group=0 & ins0412=0x00A & imm0002
{
	SoftwareInterrupt(imm0002:1);
}

#
# testset b[rA]
#
:testset "b"[regA] is group=0 & ins0412=0x00B & regA
{
	TODO(regA:4);
}

#
# cli rA
#
:cli regA is group=0 & ins0412=0x00E & regA
{
	DisableInterrupts(regA:4);
}

#
# sti rA
#
:sti regA is group=0 & ins0412=0x00F & regA
{
	EnableInterrupts(regA:4);
}

#
# pfetch [rA]
#
:pfetch [regA] is group=0 & ins0412=0x020 & regA
{
	DataCachePrefetch(regA:4);
}

#
# iflush [rA]
#
:iflush [regA] is group=0 & ins0412=0x021 & regA
{
	InstructionCacheFlush(regA:4);
}

#
# flush [rA]
#
:flush [regA] is group=0 & ins0412=0x022 & regA
{
	DataCacheFlush(regA:4);
}

#
# flushinv [rA]
#
:flushinv [regA] is group=0 & ins0412=0x023 & regA
{
	DataCacheLineInvalidate(regA:4);
}

#
# cc = 0
# <G> clc
#
:clc is group=0 & ins0012=0x1400
{
	$(C) = 0;
}

#
# cc = 1
# <G> stc
#
:stc is group=0 & ins0012=0x1401
{
	$(C) = 1;
}

#
# rA_rA = 0
# <G> clr rA_rA
#
:clr dregA is group=0 & ins0412=0x148 & dregA
{
	dregA = 0;
}

#
# rA<8-15> = 0
# <G> clr rA<8-15>
#
:clr regAh is group=0 & ins0312=0x298 & regAh
{
	regAh = 0;
}
